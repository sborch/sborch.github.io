<html>
  
<head>

  <title>dbView Import Delimited Text Into SQLite</title>

  <link rel="stylesheet" type="text/css" href="dbTools.css">

</head>
    
<body>                                             

<h1>Importing a delimited text file into a SQLite database</h1>

Open a SQLite database and run the following import command<br>
<br>
( remove optional parameters or replace sample parameter values with your own values as appropriate )<br>
<br>


<pre>
import
    src_type                       = 'text_delimited'
    src_file                       = 'REPLACE_ME_source_text_file'

    src_file_field_separator       = 'tab'
    src_file_text_qualifier        = 'none'

    src_file_header_rows           = 1
    src_file_max_rows              = 10

    src_file_field_list            = 'field1:int'
                                    ,'field2:varchar(50)'
                                    ,'field3:datetime'

    src_file_field_load_list       = 'field1'
                                    ,'field3'

    src_file_null_text             = 'NULL'
    src_file_trim_char_values      = 'true'
    src_datetime_format            = 'yyyy-MM-dd HH:mm:ss.fff'
    src_file_ignore_empty_lines    = 'true'
    src_file_ignore_lines_matching = '^\(\d+ row\(s\) affected\)$'
    src_file_ignore_ssms_sql_block = 'true'

    tgt_table                      = 'REPLACE_ME_target_table_name'
    tgt_exists_action              = 'fail'
;
</pre>

<table  border='1' cellspacing='0' cellpadding='2'>
	
<tr> <th>parameters            </th>  <th>type  </th>  <th>required </th>  <th>description/notes</th> </tr>
<tr> <td class='code'>src_type </td>  <td>string</td>  <td>required </td>  <td>set to <span class='code'>'text_delimited'</span><br><br></td> </tr>
<tr> <td class='code'>src_file </td>  <td>string</td>  <td>required </td>  <td>fully pathed name of the delimited file to read.<br><br></td> </tr>

<!-- src_file_field_separator -->
<tr> <td class='code'>src_file_field_separator </td>  <td>string</td>  <td>required </td>  
	<td>
		the character used to specify the boundary between fields in the file.<br>
		<br>
		valid values are: the word <span class='code'>'tab'</span> or a single character 
		(e.g. <span class='code'>','</span> or <span class='code'>'|'</span> or <span class='code'>';'</span>)<br><br>
	</td>
</tr>

<!-- src_file_text_qualifier -->
<tr> <td class='code'>src_file_text_qualifier </td>  <td>string</td>  <td><span class='test'>optional</span></td>  
	<td>
		the character used to specify where a text value begins and ends.<br>
		<br>
		valid values are: <span class='code'>'none'</span>, <span class='code'>'single-quote'</span>, or <span class='code'>'double-quote'</span>	(default is <span class='code'>'none'</span> if not defined)<br>
		<br>
	</td>
</tr>

<!-- src_file_header_rows -->
<tr> <td class='code'>src_file_header_rows </td>  <td>integer</td>  <td><span class='test'>optional</span></td>  
	<td>
    the number of initial (header) rows to skip in the file.<br>
    <br>
    set to a value of 1 if the first row in the file contains the field names. see additional notes under <span class='code'>src_file_field_list</span>
    for more detail on defining field names and datatypes.<br>
    <br>
	</td>
</tr>

<!-- src_file_max_rows -->
<tr> <td class='code'>src_file_max_rows </td>  <td>integer</td>  <td><span class='test'>optional</span></td>  
	<td>
    maximum number of data rows to import from source text file (default is to read all rows if not defined).<br>
    <br>
    note - this is primarily intended for testing and/or partial loads of very large files.<br>
    <br>
	</td>
</tr>

<!-- src_file_field_list -->
<tr> <td class='code'>src_file_field_list </td>  <td>string</td>  <td><span class='test'>optional</span></td>  
	<td>
		list of field names and datatypes in a comma-delimited format<br>
		<br>
		<u>for example</u><br><br>
		<span class='code'>
<pre>
src_file_field_list = 'field1:int'
                     ,'field2:varchar(50)'
                     ,'field3:datetime'
                     ,'...'		                      
</pre>
		</span>
		
		<b>*** IMPORTANT NOTE ***</b><br>
		please refer to SQLite documentation (<a target='_blank' href="https://www.sqlite.org/datatype3.html">https://www.sqlite.org/datatype3.html</a>) 
		for a detailed explanation of how SQLite defines and implements dynamic typing. 
		it is different and more flexible than the static typing used by more traditional RDBMS.<br>
		<br>
		
    <u>additional notes</u><br>
    <br>
    1.  if <span class='code'>src_file_field_list</span> is not defined and <span class='code'>src_file_header_rows = 0</span> 
    then field names will be automatically generated as <span class='code'>'field1:text', 'field2:text', 'field3:text', ...</span> etc.<br>
    <br>
    2.  if <span class='code'>src_file_field_list</span> is not defined and <span class='code'>src_file_header_rows = 1</span> 
    then the first row of the file will be used to define the field names with a datatype of text<br>
    <br>
	</td>
</tr>

<!-- src_file_field_load_list -->
<tr> <td class='code'>src_file_field_load_list      </td>  <td>string</td>  <td><span class='test'>optional</span></td>  
	<td>
		list of field names to load in a comma-delimited format.  these names need to match the names defined in the file header row, or the names defined in <span class='code'>src_file_field_list</span><br> 
		<br>
		<u>for example</u><br>
		<span class='code'>
<pre>
src_file_field_load_list = 'field1'
                          ,'field2'
                          ,'field3'
                          ,'...'			                      
</pre>
		</span>
		
    <u>additional notes</u><br>
    <br>
    1. if <span class='code'>src_file_field_load_list</span> is not defined then *ALL* fields in the source file will be loaded into the target table.<br>
    <br>
    2. if <span class='code'>src_file_field_load_list</span> is defined then *ONLY* the named fields in the list will be loaded into the target table. All other fields will be discarded.<br>
    <br>
	</td>
</tr>

<!-- src_file_null_text -->
<tr> <td class='code'>src_file_null_text            </td>  <td>string</td>  <td><span class='test'>optional</span></td>  
	<td>
		string value that represents databasenull values in the source file.<br><br>
		For example, text files exported from SQL Server will often have database null values set to the literal string <span class='code'>'NULL'</span>, 
		so to load them as database null values in SQLite set<br><br><span class='code'>src_file_null_text = 'NULL'</span><br><br>
  </td>
 </tr>

<!-- src_file_ignore_empty_lines -->
<tr> <td class='code'>src_file_ignore_empty_lines   </td>  <td>string</td>  <td><span class='test'>optional</span></td>  
	<td>
	determines whether or not empty lines are ignored by the load.<br>
	<br>
	valid values are <span class='code'>'true'</span> or <span class='code'>'false'</span> (default is <span class='code'>'false'</span> if not defined).<br>
	<br>
	n.b. normally the empty lines will cause the load to fail, so you may need to set this to <span class='code'>'true'</span> if you are loading source files generated 
	from sql server management studio which often have an empty line at the end of the file.<br>
	<br>
	</td>
</tr>

<!-- src_file_ignore_lines_matching -->
<tr> <td class='code'>src_file_ignore_lines_matching</td>  <td>string</td>  <td><span class='test'>optional</span></td>  
	<td>
		regular expression pattern for lines to ignore<br>
		<br>
		<u>for example</u><br>
		to ignore lines like: <span class='code'>(123 row(s) affected)</span><br>
		<br>
		set <span class='code'>src_file_ignore_lines_matching='^\(\d+ row\(s\) affected\)$'</span><br><br>
	</td>
</tr>

<!-- src_file_ignore_ssms_sql_block -->
<tr> <td class='code'>src_file_ignore_ssms_sql_block   </td>  <td>string</td>  <td><span class='test'>optional</span></td>  
	<td>
	allows you to ignore the SQL comment block that SQL Server Management Studio (SSMS) adds to the top of the data file when the
	'Include query in the result set' option is checked in SSMS.<br>
	<br>
	valid values are <span class='code'>'true'</span> or <span class='code'>'false'</span> (default is <span class='code'>'false'</span> if not defined).<br>
	<br>
	
	for example if <span class='code'>src_file_ignore_ssms_sql_block='true'</span> then the first four 'comment' lines of the following sample file would be ignored.<br>
	<br>
	note that the comment block must be at the top of the file and be be formatted <u>exactly</u> as below.<br>
	<br> 
	
<pre>
/*------------------------
select *
from dbo.test_tb;
------------------------*/
field1,field2
10,Closed
20,Open
30,Pending
40,Resolved
</pre>

	<br>
	</td>
</tr>



<!-- src_file_trim_char_values -->
<tr> <td class='code'>src_file_trim_char_values </td>  <td>string</td>  <td><span class='test'>optional</span></td>  
	<td>
	<span class='code'>'true'</span> or <span class='code'>'false'</span> (default is <span class='code'>'true'</span> if not defined)<br>
	<br>
	determines whether leading and trailing whitespace is trimmed from values when loading values from delimited text files into character fields. setting this value to false can be useful when profiling data files.<br>
	<br>
	<u>for example</u><br>
	<span class='code'>'Apple  '</span> trims to <span class='code'>'Apple'</span>
	<br>
	</td>
</tr>

<!-- src_datetime_format -->
<tr> <td class='code'>src_datetime_format </td>  <td>string</td>  <td><span class='test'>optional</span></td>  
	<td>
	format string to use when parsing values for loading into a datetime field.  This can be useful if you have an unusual datetime format that does not auto-parse.<br>
	<br>
	see microsoft documentation on datetime format strings. <a target='_blank' href='https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings'>Custom Date and Time Format Strings</a><br><br>
	</td>
</tr>
	
<!-- tgt_table -->
<tr> <td class='code'>tgt_table </td>  <td>string</td>  <td>required </td>  
	<td>
		name of table into which data should be loaded<br><br>
	</td>
</tr>
	
<!-- tgt_exists_action -->
<tr> <td class='code'>tgt_exists_action </td>  <td>string</td>  <td>required </td>  
	<td>
		action to take if the specified target table already exists<br>
		<br>
		valid values are <span class='code'>'replace'</span> or <span class='code'>'fail'</span> (default is <span class='code'>'fail'</span> if not defined)<br><br>
	</td>
</tr>

</table> 

    
</body>

</html>
