<html>
  
<head>

  <titledbView About</title>

  <style type="text/css">
    h1        {font-family:verdana,sans-serif; font-size:14pt}
    h2        {font-family:verdana,sans-serif; font-size:11pt}
    h3        {font-family:verdana,sans-serif; font-size:10pt}

    body      {font-family:verdana,sans-serif; font-size:10pt}

    table     {font-family:verdana,sans-serif; font-size:10pt;}

    th        {vertical-align:top; text-align:left; background:whitesmoke}
    th.yellow {vertical-align:top; text-align:left; background:lemonchiffon}

    td        {vertical-align:top;}
    td.code   {vertical-align:top;font-family:consolas,courier,monospace;color:teal}

    pre       {font-family:consolas,courier,monospace;color:teal}

    span.test {color:gray}
    span.code {font-family:consolas,courier,monospace;color=teal}
    
    a:link    {color:blue; text-decoration:underline}
    a:visited {color:blue; text-decoration:underline}
    a:active  {color:blue; text-decoration:underline}
    a:hover   {color:blue; text-decoration:underline; background:yellow; }

  </style>

</head>
    
<body>                                             

<h1>Overview</h1>
<p>dbView is a query and analysis tool that is intended provide a consistent environment in which to work with different types of databases.  
I created and maintain dbView to support my day-to-day work and for this reason dbView is continually evolving and changing as my needs change.
Please see me with any questions and/or for an overview of dbView capabilities.</p>
Thanks, Steve Borcherding

<h1>SQLite database library</h1>
<p>
I rely heavily on SQLite (<a target='_blank' href='http://www.sqlite.org'>http://www.sqlite.org</a>) as a versatile database engine for much of the underpinnings 
of dbView and my related data-related tools. SQLite is a software library that implements a self-contained, serverless, zero-configuration, transactional SQL database engine.
</p>

<p>
Note that SQLite uses dynamic typing rather than the static typing we are used to with SQL Server and other traditional RDBMS engines.  
It’s a bit different but very flexible and can be especially useful for working with text files and ad-hoc data analysis across multiple data sources.
For this reason you should review the SQLite documentation on datatypes at <a target='_blank' href="https://www.sqlite.org/datatype3.html">https://www.sqlite.org/datatype3.html</a>.
</p>
 
<p>Also if you are interested, I use an ADO.NET provider for SQLite called
	<a target='_blank' href='http://system.data.sqlite.org/index.html/doc/trunk/www/index.wiki'>System.Data.SQLite</a>.
	This library allows for easy integration of SQLite functionality into a .NET application.
</p> 
 
 
<h3>Important Note - Connecting to SQLite Databases</h3>
<p>If you want the connection to fail if the specified database file does *NOT* exist, then set <span class='code'><strong>FailIfMissing=True</strong></span></p>
<table><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td>
<pre>
SQLITE:
;Data Source="C:\Temp\MyDatabase.db"
;Foreign Keys=True
;Read Only=False
;FailIfMissing=True
</pre>
</td></tr></table>

<p>Otherwise if you want the connection to always succeed, then set <span class='code'><strong>FailIfMissing=False</strong></span>.
This will cause a new empty SQLite database file to be automatically created if the specified file does not already exist.</p>
<table><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td>
<pre>SQLITE:
;Data Source="C:\Temp\MyDatabase.db"
;Foreign Keys=True
;Read Only=False
;FailIfMissing=False
</pre>
</td></tr></table>


<!-- 
-------------------------------------------------------------------------------
-- Importing and Exporting Data
-------------------------------------------------------------------------------
-->

<h1 id='top'>Importing and Exporting Data</h1>

<h2>exporting data from any supported database</h2>
<table><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td>
1.1 - export data to delimited text file<br>
1.2 - export data to sql insert script text file<br>
1.3 - export data to SQLite database<br>
</td></tr></table>

<h2>importing data into a SQL Server database</h2>
<table><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td>
2.1 - import (buik load) from SQL Server database into a SQL Server database<br>
2.2 - import from SQLite database into a SQL Server database<br>
2.3 - import (bulk load) delimited text file into SQL Server database<br>
</td></tr></table>

<h2>importing data into a SQLite database</h2>
<table><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td>
<a href='#3.1'>3.1 - import a delimited text file into a SQLite database</a><br>
3.2 - import a fixed-width text file into a SQLite database<br>
3.3 - import from SQL Server database into a SQLite database<br>
3.4 - import from SQLite database into a SQLite database<br>
</td></tr></table>

<br>
<br>

<!-- 
-------------------------------------------------------------------------------
-- 3.1 - Importing a delimited text file into a SQLite database
-------------------------------------------------------------------------------
-->

<table  border='1' cellspacing='0' cellpadding='2'>
  
<tr>
<th class='yellow' id='3.1'>3.1 - Importing a delimited text file into a SQLite database <span><a href='#top'>(top)</a></span></th>
</tr>

<tr>
<td>
Open a SQLite database and run the following import command<br>
(replace example parameter values with your own values)

<pre>
import
    src_type                       = 'text_delimited'
    src_file                       = 'REPLACE_ME_source_text_file'

    src_file_field_separator       = 'tab'
    src_file_text_qualifier        = 'none'

    src_file_header_rows           = 1
    src_file_max_rows              = 10

    src_file_field_list            = 'field1:int'
                                    ,'field2:varchar(50)'
                                    ,'field3:datetime'

    src_file_field_load_list       = 'field1'
                                    ,'field3'

    src_file_null_text             = 'NULL'
    src_file_trim_char_values      = 'true'
    src_datetime_format            = 'yyyy-MM-dd HH:mm:ss.fff'
    src_file_ignore_empty_lines    = 'true'
    src_file_ignore_lines_matching = '^\(\d+ row\(s\) affected\)$'
    src_file_ignore_ssms_sql_block = 'true'

    tgt_table                      = 'REPLACE_ME_target_table_name'
    tgt_exists_action              = 'fail'
;
</pre>

<table  border='1' cellspacing='0' cellpadding='2'>
	
<tr> <th>parameters            </th>  <th>type  </th>  <th>required </th>  <th>description/notes</th> </tr>
<tr> <td class='code'>src_type </td>  <td>string</td>  <td>required </td>  <td>set to <span class='code'>'text_delimited'</span><br><br></td> </tr>
<tr> <td class='code'>src_file </td>  <td>string</td>  <td>required </td>  <td>fully pathed name of the delimited file to read.<br><br></td> </tr>

<!-- src_file_field_separator -->
<tr> <td class='code'>src_file_field_separator </td>  <td>string</td>  <td>required </td>  
	<td>
		the character used to specify the boundary between fields in the file.<br>
		<br>
		valid values are: the word <span class='code'>'tab'</span> or a single character 
		(e.g. <span class='code'>','</span> or <span class='code'>'|'</span> or <span class='code'>';'</span>)<br><br>
	</td>
</tr>

<!-- src_file_text_qualifier -->
<tr> <td class='code'>src_file_text_qualifier </td>  <td>string</td>  <td><span class='test'>optional</span></td>  
	<td>
		the character used to specify where a text value begins and ends.<br>
		<br>
		valid values are: <span class='code'>'none'</span>, <span class='code'>'single-quote'</span>, or <span class='code'>'double-quote'</span>	(default is <span class='code'>'none'</span> if not defined)<br>
		<br>
	</td>
</tr>

<!-- src_file_header_rows -->
<tr> <td class='code'>src_file_header_rows </td>  <td>integer</td>  <td><span class='test'>optional</span></td>  
	<td>
    the number of initial (header) rows to skip in the file.<br>
    <br>
    set to a value of 1 if the first row in the file contains the field names. see additional notes under <span class='code'>src_file_field_list</span>
    for more detail on defining field names and datatypes.<br>
    <br>
	</td>
</tr>

<!-- src_file_max_rows -->
<tr> <td class='code'>src_file_max_rows </td>  <td>integer</td>  <td><span class='test'>optional</span></td>  
	<td>
    maximum number of data rows to import from source text file (default is to read all rows if not defined).<br>
    <br>
    note - this is primarily intended for testing and/or partial loads of very large files.<br>
    <br>
	</td>
</tr>

<!-- src_file_field_list -->
<tr> <td class='code'>src_file_field_list </td>  <td>string</td>  <td><span class='test'>optional</span></td>  
	<td>
		list of field names and datatypes in a comma-delimited format<br>
		<br>
		<u>for example</u><br><br>
		<span class='code'>
<pre>
src_file_field_list = 'field1:int'
                     ,'field2:varchar(50)'
                     ,'field3:datetime'
                     ,'...'		                      
</pre>
		</span>
		
		<b>*** IMPORTANT NOTE ***</b><br>
		please refer to SQLite documentation (<a target='_blank' href="https://www.sqlite.org/datatype3.html">https://www.sqlite.org/datatype3.html</a>) 
		for a detailed explanation of how SQLite defines and implements dynamic typing. 
		it is different and more flexible than the static typing used by more traditional RDBMS.<br>
		<br>
		
    <u>additional notes</u><br>
    <br>
    1.  if <span class='code'>src_file_field_list</span> is not defined and <span class='code'>src_file_header_rows = 0</span> 
    then field names will be automatically generated as <span class='code'>'field1:text', 'field2:text', 'field3:text', ...</span> etc.<br>
    <br>
    2.  if <span class='code'>src_file_field_list</span> is not defined and <span class='code'>src_file_header_rows = 1</span> 
    then the first row of the file will be used to define the field names with a datatype of text<br>
    <br>
	</td>
</tr>

<!-- src_file_field_load_list -->
<tr> <td class='code'>src_file_field_load_list      </td>  <td>string</td>  <td><span class='test'>optional</span></td>  
	<td>
		list of field names to load in a comma-delimited format.  these names need to match the names defined in the file header row, or the names defined in <span class='code'>src_file_field_list</span><br> 
		<br>
		<u>for example</u><br>
		<span class='code'>
<pre>
src_file_field_load_list = 'field1'
                          ,'field2'
                          ,'field3'
                          ,'...'			                      
</pre>
		</span>
		
    <u>additional notes</u><br>
    <br>
    1. if <span class='code'>src_file_field_load_list</span> is not defined then *ALL* fields in the source file will be loaded into the target table.<br>
    <br>
    2. if <span class='code'>src_file_field_load_list</span> is defined then *ONLY* the named fields in the list will be loaded into the target table. All other fields will be discarded.<br>
    <br>
	</td>
</tr>

<!-- src_file_null_text -->
<tr> <td class='code'>src_file_null_text            </td>  <td>string</td>  <td><span class='test'>optional</span></td>  
	<td>
		string value that represents databasenull values in the source file.<br><br>
		For example, text files exported from SQL Server will often have database null values set to the literal string <span class='code'>'NULL'</span>, 
		so to load them as database null values in SQLite set<br><br><span class='code'>src_file_null_text = 'NULL'</span><br><br>
  </td>
 </tr>

<!-- src_file_ignore_empty_lines -->
<tr> <td class='code'>src_file_ignore_empty_lines   </td>  <td>string</td>  <td><span class='test'>optional</span></td>  
	<td>
	determines whether or not empty lines are ignored by the load.<br>
	<br>
	valid values are <span class='code'>'true'</span> or <span class='code'>'false'</span> (default is <span class='code'>'false'</span> if not defined).<br>
	<br>
	n.b. normally the empty lines will cause the load to fail, so you may need to set this to <span class='code'>'true'</span> if you are loading source files generated 
	from sql server management studio which often have an empty line at the end of the file.<br>
	<br>
	</td>
</tr>

<!-- src_file_ignore_lines_matching -->
<tr> <td class='code'>src_file_ignore_lines_matching</td>  <td>string</td>  <td><span class='test'>optional</span></td>  
	<td>
		regular expression pattern for lines to ignore<br>
		<br>
		<u>for example</u><br>
		to ignore lines like: <span class='code'>(123 row(s) affected)</span><br>
		<br>
		set <span class='code'>src_file_ignore_lines_matching='^\(\d+ row\(s\) affected\)$'</span><br><br>
	</td>
</tr>

<!-- src_file_ignore_ssms_sql_block -->
<tr> <td class='code'>src_file_ignore_ssms_sql_block   </td>  <td>string</td>  <td><span class='test'>optional</span></td>  
	<td>
	allows you to ignore the SQL comment block that SQL Server Management Studio (SSMS) adds to the top of the data file when the
	'Include query in the result set' option is checked in SSMS.<br>
	<br>
	valid values are <span class='code'>'true'</span> or <span class='code'>'false'</span> (default is <span class='code'>'false'</span> if not defined).<br>
	<br>
	
	for example if <span class='code'>src_file_ignore_ssms_sql_block='true'</span> then the first four 'comment' lines of the following sample file would be ignored.<br>
	<br>
	note that the comment block must be at the top of the file and be be formatted <u>exactly</u> as below.<br>
	<br> 
	
<pre>
/*------------------------
select *
from dbo.test_tb;
------------------------*/
field1,field2
10,Closed
20,Open
30,Pending
40,Resolved
</pre>

	<br>
	</td>
</tr>



<!-- src_file_trim_char_values -->
<tr> <td class='code'>src_file_trim_char_values </td>  <td>string</td>  <td><span class='test'>optional</span></td>  
	<td>
	<span class='code'>'true'</span> or <span class='code'>'false'</span> (default is <span class='code'>'true'</span> if not defined)<br>
	<br>
	determines whether leading and trailing whitespace is trimmed from values when loading values from delimited text files into character fields. setting this value to false can be useful when profiling data files.<br>
	<br>
	<u>for example</u><br>
	<span class='code'>'Apple  '</span> trims to <span class='code'>'Apple'</span>
	<br>
	</td>
</tr>

<!-- src_datetime_format -->
<tr> <td class='code'>src_datetime_format </td>  <td>string</td>  <td><span class='test'>optional</span></td>  
	<td>
	format string to use when parsing values for loading into a datetime field.  This can be useful if you have an unusual datetime format that does not auto-parse.<br>
	<br>
	see microsoft documentation on datetime format strings. <a target='_blank' href='https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings'>Custom Date and Time Format Strings</a><br><br>
	</td>
</tr>
	
<!-- tgt_table -->
<tr> <td class='code'>tgt_table </td>  <td>string</td>  <td>required </td>  
	<td>
		name of table into which data should be loaded<br><br>
	</td>
</tr>
	
<!-- tgt_exists_action -->
<tr> <td class='code'>tgt_exists_action </td>  <td>string</td>  <td>required </td>  
	<td>
		action to take if the specified target table already exists<br>
		<br>
		valid values are <span class='code'>'replace'</span> or <span class='code'>'fail'</span> (default is <span class='code'>'fail'</span> if not defined)<br><br>
	</td>
</tr>

</table> 



    
</body>

</html>
